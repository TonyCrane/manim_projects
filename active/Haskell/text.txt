「直观理解Haskell中的Functor、Applicative与Monad」

从范畴论而来的Functor、Applicative与Monad等类型类一直是Haskell学习中的重点与难点
这期视频就从一个不太学术、不太严谨的角度来直观理解一下Haskell中的函子等类型类的作用
画面：
    本期视频只是一个试验性视频
    面向人群：
        有一点Haskell基础
        且对于Functor等概念感到困惑
    如果效果好的话，可以考虑做一系列Haskell入门的视频（挖坑）

首先来回顾一下Haskell中的函数与几个类型
Haskell中的函数都是柯里化的，也就是说，它们都可以看成接收一个值返回另一个值的函数，返回的值也可以是函数
比如二元函数(+)，在接受了参数1后会返回一个新的函数(+1)，而函数(+1)接收了参数2后会返回一个值3
而且函数的接收值和返回值也可以是不同的类型，比如show函数，接收一个Show的实例，返回一个字符串
所以函数f接收x，返回f(x)，它的类型签名也就可以写成a -> b

再回顾一下Maybe、[]、IO等类型构造器，它们都是接收一个类型，返回一个新的具体类型
比如Just 1就是一个Maybe Int类型的值
Just也可以看成接收一个值，然后把这个值放在了一个盒子里，Just 1就相当于把1放在了一个盒子里
Nothing也可以看成一个Maybe Int类型的值，它相当于一个什么都没放的空盒子
如果把Maybe这个类型构造器的类型签名写成f，那么Just 1等这种装着值的盒子的类型签名就可以写成f a

但是这是如果我们有一个函数，和一个盒子，怎么将这个函数应用在这个盒子中的值上？
这个函数的输入是一个值，它并不能接收一个盒子，因此也就不能直接将这个函数应用在盒子上
但是Functor的fmap函数就可以很方便地帮我们达到这一个需要
前面说到的那些可以看作盒子的类型构造器就是函子（Functor）的实例
fmap接收一个函数，和一个装在盒子里的值，它将函数应用在盒子中的值上，并返回包含结果的盒子
所以对于这个操作，可以看作，将盒子中的值1取了出来，然后传入给了函数(+3)，返回了4，又装进了盒子中
而且对于列表这种会包含很多值的盒子，fmap也会将盒子中的值逐一取出，传入给函数，然后逐一放回盒子
再来看如果传入的是一个空盒子呢，比如Nothing
这时无法从盒子中取出值，也就不会应用函数，从而直接返回了一个空盒子
对于后面要讲的也一样，只要有盒子是空的，那么就都会直接返回空盒子

但是如果我们不小心将一个二元函数作为第一个参数传入给了fmap，那么得到的结果就会是装在盒子中的函数
所以现在问题又来了：怎么将一个装在盒子里的函数应用在装在盒子中的值上？
装有盒子的函数本质上还是一个盒子，它不可能直接接收一个值或者一个装有值的盒子
因此fmap已经无法达到这个需求，这时就需要应用函子（Applicative）的apply（<*>）函数
此时看作盒子的类型构造器上升成为了应用函子
apply函数接收一个装有函数的盒子，和一个装有值的盒子，将函数和值全部取出，应用后再把返回的结果放回盒子中
对于这个例子，盒子中的(+3)函数被取了出来，然后第二个盒子中的值1也被取了出来，应用后得到结果4，又装回了盒子中
对于列表，盒子中也会装着多个函数，这是就会先取出第一个函数，然后应用在第二个盒子的所有值上，再去第二个函数，应用在第二个盒子的所有值上
最后将得到的所有结果平铺着装到盒子中

但是如果我们的要求更刁钻一点，给出的函数是接收一个普通的值，返回一个盒子的函数
怎么将这个函数应用在一个盒子上，并得到一个单独的盒子？
如果是使用fmap将这个函数应用在盒子上，那么得到的结果将会是套有两层盒子的值
并且我们也没有一个单独的去掉一层盒子的函数
这时就需要了单子（Monad）的bind（>>=）函数，可以使用bind函数的盒子也就升级为了单子
和我们的需求一样，但是和fmap以及apply的方向相反，它先接收一个装有值的盒子，然后是一个特殊的接收值返回盒子的函数，返回一个盒子
同样，对于这个例子，它将盒子中的值取出来，然后传入给这个函数，直接得到作为结果的盒子
也就达到了我们的需求

那Monad又有什么实际用途呢？
比如想要从输入中获取一个文件名，然后读取这个文件，并将其中内容输出
我们知道，在Haskell中，有副作用的函数的返回值都被包装在了IO这个类型类中，也就相当于包在了一个盒子中
用getLine从输入中获取文件名，得到的就是一个包在盒子中的字符串
然后需要用readFile读取文件，但它输入的是一个字符串，输出的是一个装有文件内容字符串的盒子
所以就可以使用bind函数直接将readFile函数应用在getLine的结果上
而输出呢，要用到putStrLn函数，它也是一个接收字符串，返回一个盒子的函数，只不过会将字符串输出，然后返回一个装有空元组的盒子
因此也可以将上面得到的装有文件内容的盒子直接使用bind函数传入给putStrLn函数输出
这样整个操作就是getLine >>= readFile >>= putStrLn，非常的简便清晰

关于Functor、Applicative、Monad的直观盒子比喻的理解就到这里了
其实它们简单的用法上不过就是把一些古怪类型的函数应用在盒子中的值上，然后再返回一个盒子

那么这期视频你觉得怎么样呢？如果效果可以的话，不妨点个三连告诉我一下
如果反馈好的话，我会尝试做一系列Haskell入门的视频
那么我们下期再见了（如果有的话）